<#
// https://github.com/tikrimi/MvcScaffolding4TwitterBootstrapMvc/blob/master/T4Scaffolding/Core/EnvDTE/EnvDTEExtensions.cs
// https://msdn.microsoft.com/en-us/magazine/mt790203
// http://weblogs.thinktecture.com/cweyer/2009/06/generating-async-wcf-operationcontract-signatures-with-a-t4-template.html
// https://github.com/dotnet/roslyn/blob/master/src/VisualStudio/Core/Impl/CodeModel/InternalElements/CodeParameter.cs
#>

<#@ template language="C#" debug="true" hostspecific="true" #> 
<#@ assembly name="EnvDTE" #>
<#@ assembly Name="System.Core.dll" #>
<#@ assembly name="System.ComponentModel.DataAnnotations.dll" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>

<#@ output extension=".ts" #>
<#@ include file="TypescriptGenerator.ttinclude"#>

<# 
var hostServiceProvider = (System.IServiceProvider)this.Host;
var dte = (DTE)hostServiceProvider.GetService(typeof(DTE));
var manager = new Manager(Host, GenerationEnvironment, true) { OutputPath = Path.GetDirectoryName(Host.TemplateFile) };
var project = dte.Solution.FindProjectItem(this.Host.TemplateFile).ContainingProject as EnvDTE.Project;
var scripter = new Scripter();
#>
<# manager.StartHeader(); #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: <#= Environment.Version #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<# manager.EndHeader(); #>
<# manager.StartBlock("generated.api.ts"); #>
import { Injectable } from '@angular/core';
import { Http, Response } from '@angular/http';
import { Observable } from "rxjs";
import 'rxjs/add/operator/map';

<#
var serviceOutput = scripter
	.UsingReader(new DteNamespaceReader(project, "Web.Controllers", ""))
	.UsingFormatter(new Angular2ServiceFormatter())
	.ToString();

var modelOutput = scripter
	.UsingReader(new DteNamespaceReader(project, "Web.Controllers", ""))
	.UsingFormatter(new TypeScriptModelFormatter(project))
	.ToString();

WriteLine(serviceOutput);
WriteLine(modelOutput);
#>
<# manager.EndBlock(); #>
<# manager.Process(true); #>
<#+ 

public class Scripter
{
	private IReader Reader { get; set; }
	private IFormatter Formatter { get; set; }

	public Scripter UsingReader(IReader reader)
    {
        if (reader == null) 
            throw new ArgumentNullException("reader");
        
		Reader = reader;
        return this;
    }

	public Scripter UsingFormatter(IFormatter formatter)
    {
        this.Formatter = formatter;
        return this;
    }

	public string ToString()
	{
		return Formatter.Format(Reader.Classes);
	}
}

public interface IReader
{
	List<ScriptCodeClass> Classes { get; set; }
}

public interface IFormatter
{
	string Format(List<ScriptCodeClass> classes);
}

public class ScriptCodeClass
{
	public string Name { get; set; }
	public string Comment { get; set; }
	public List<ScriptCodeFunction> Functions { get; set; }
	public CodeClass Class { get; set; } // TODO: Leaking abstraction... 
}
public class ScriptCodeFunction
{
	public string Name { get; set; }
	public string Comment { get; set; }
	public ScriptCodeType ReturnType { get; set; }
	public List<ScriptCodeParameter> Parameters { get; set; }
	public List<ScriptCodeAttribute> Attributes { get; set; }
	public CodeFunction Class { get; set; } // TODO: Leaking abstraction...
}
public class ScriptCodeAttribute
{
	public string Name { get; set; }
	public string Value { get; set; }
}
public class ScriptCodeParameter 
{
	public string Name { get; set; }
	public ScriptCodeType Type { get; set; } // TODO: Leaking abstraction...
	public CodeParameter CodeParameter { get; set; } // TODO: Leaking abstraction...
	public string DefaultValue { get; set; }
	public List<ScriptCodeType> Members { get; set; }
}
public class ScriptCodeType
{
	public string Name { get; set; }
	public string FullName { get; set; }
	public string Comment { get; set; }
	public string Namespace { get; set; }
	public bool IsPublic { get; set; }
	public bool IsArray { get; set; }
	public CodeTypeRef TypeRef { get; set; } // TODO: Leaking abstraction...
	public CodeType Type { get; set; } // TODO: Leaking abstraction...
	public ScriptCodeType ArrayType { get; set; } 
	public ScriptCodeType BaseType { get; set; } 
}


public class DteNamespaceReader : IReader
{
	public List<ScriptCodeClass> Classes { get; set; }

	public DteNamespaceReader(EnvDTE.Project project, string matchingNamespace, string matchingClassName) 
	{
		Classes = GetClasses(project, matchingNamespace, matchingClassName);
	}

	public List<ScriptCodeClass> GetClasses(EnvDTE.Project project, string matchingNamespace, string matchingClassName) 
	{
		var classes = new List<ScriptCodeClass>();

		var projectClasses = DteHelper.FindClasses(project.CodeModel.CodeElements, matchingClassName, matchingNamespace, false);
		foreach (var projectClass in projectClasses)
		{
			var scriptCodeClass = new ScriptCodeClass 
			{
				Name = projectClass.Name,
				Comment = projectClass.DocComment,
				Functions = new List<ScriptCodeFunction>(),
				Class = projectClass,
			}; 

			var functionsClasses = DteHelper.FindFunctions(projectClass.Children);
			foreach (var functionClass in functionsClasses) 
			{
				var scriptCodeFunction = new ScriptCodeFunction 
				{
					Name = Helper.FirstLetterToLowerCase(functionClass.Name),
					Comment = functionClass.DocComment,
					ReturnType = DteHelper.ConvertToScriptCodeType(functionClass.Type.CodeType, project),
					Parameters = new List<ScriptCodeParameter>(),
					Attributes = new List<ScriptCodeAttribute>(),
					Class = functionClass,
				};

				foreach(CodeElement attributeElement in functionClass.Attributes)
				{
					CodeAttribute attribute = attributeElement as CodeAttribute;
				
					if (attribute == null)
						continue;
				
					var scriptCodeAttribute = new ScriptCodeAttribute 
					{
						Name = attribute.Name,
						Value = attribute.Value,
					};
					scriptCodeFunction.Attributes.Add(scriptCodeAttribute);
				}

				var parameterClasses = DteHelper.FindParameters(functionClass);
				foreach (var parameterClass in parameterClasses) 
				{
					var scriptCodeParameter = new ScriptCodeParameter 
					{
						Name = parameterClass.Name, // Uses the same parameter name in Javascript and C# 
						Type = DteHelper.ConvertToScriptCodeType(parameterClass.Type.CodeType, project),
						DefaultValue ="", // TODO
						CodeParameter = parameterClass
					};
					scriptCodeFunction.Parameters.Add(scriptCodeParameter);
				}

				scriptCodeClass.Functions.Add(scriptCodeFunction);
			}
		
			classes.Add(scriptCodeClass);
		} 

		return classes;
	}
}

public class Angular2ServiceFormatter : IFormatter
{
	public string Format(List<ScriptCodeClass> classes)
	{
		var sb = new StringBuilder();

		foreach (var controller in classes) 
		{ 
			var controllerRoute = DteHelper.TryGetRouteAttribute(controller.Class);
		
			sb.AppendLine("@Injectable()");
			sb.AppendLine("export class " + controller.Name.Replace("Controller", "Repository") + " {"); // TODO: Naming conventions should be configurable instead of hardcoded
			sb.AppendLine("\tconstructor(private http: Http) { }");
		
			foreach (var function in controller.Functions)
			{
				string actionRoute =  DteHelper.TryGetRouteAttribute(function.Class);
				string route =  controllerRoute + "/" + actionRoute;
				var action = Helper.TryGetActionAttribute(function.Attributes); 
				
				if (String.IsNullOrEmpty(action))
					continue;
					
				var parametersWithTypeList = function.Parameters.Select(x => x.Name + " : " + Helper.ConvertToTypescriptType(x.Type.FullName)).ToList();
				var parametersWithNamesList = function.Parameters.Select(x => x.Name).ToList();
				var parametersWithType = String.Join(",", parametersWithTypeList);
				var parametersWithNames = String.Join(",", parametersWithNamesList);
		
				sb.AppendLine("");
				sb.Append(PrintComment(function.Comment, 1, 1));
				sb.Append("\t" + function.Name + "(" + parametersWithType + ")");
		
				// Handle return type
				if (function.ReturnType.Type.Name != "Void") 
				{
					if (function.ReturnType.IsArray)
					{
						sb.Append(" : Observable<" + function.ReturnType.ArrayType.FullName + "[]>");
					}
					else 
					{
						sb.Append(" : Observable<" + function.ReturnType.Type.FullName + ">");
					}
				}
		
				sb.AppendLine(" {");
				sb.AppendLine("\t\treturn this.http"); 
		
				if (action == "post" || action == "put")
				{
					sb.AppendLine("\t\t\t." + String.Format("{0}(\"{1}\", {2})", action, route, parametersWithNames));
				}
				else if (parametersWithNames.Count() > 0 && (action == "delete" || action == "get"))
				{
					if (string.IsNullOrEmpty(actionRoute))
						sb.AppendLine("\t\t\t." + String.Format("{0}(\"{1}\" + {2})", action, route, parametersWithNames));
					else
						sb.AppendLine("\t\t\t." + String.Format("{0}(\"{1}/\" + {2})", action, route, parametersWithNames));
				}
				else   
				{ 
					sb.AppendLine("\t\t\t." + String.Format("{0}(\"{1}\")", action, route)); 
				}
		 
				sb.AppendLine("\t\t\t.map((response: Response) => response.json())");
				sb.AppendLine("\t\t\t.catch((error:any) => Observable.throw(error.json().error || 'Server error'));");
				sb.AppendLine("\t}");
			}
		
			sb.AppendLine("}");
			sb.AppendLine("");
		} 

		return sb.ToString();
	}

	private string PrintComment(string comment, int level, int skip = 2)
	{
		var sb = new StringBuilder();

		if (!String.IsNullOrEmpty(comment))
		{
			var comments = comment.Split('\n').Skip(skip);
			var commentArray = comments.Take(comments.Count() - skip).ToArray();
			sb.Append(new String('\t', level ) + "// " + String.Join(new String('\t', level) + "// ", commentArray));
		}

		return sb.ToString();
	}
}

public class TypeScriptModelFormatter : IFormatter
{
	EnvDTE.Project _project;

	public TypeScriptModelFormatter(EnvDTE.Project project)
	{
		_project = project;
	}
	
	public string Format(List<ScriptCodeClass> classes)
	{
		var sb = new StringBuilder();
		var codeTypes = FindTypes(classes);
		
		sb.AppendLine(PrintModelTree(codeTypes));
		return sb.ToString();
	}
	
	private List<ScriptCodeType> FindTypes(List<ScriptCodeClass> classes)
	{
		var knownTypesString = new List<string>();
		var codeTypes = new List<ScriptCodeType>();
		var searchTree = new Stack<ScriptCodeType>();

		foreach (var controller in classes) 
		{ 
			foreach (var function in controller.Functions)
			{
				var action = Helper.TryGetActionAttribute(function.Attributes);

				// Filter everything without an action attribute
				if (String.IsNullOrEmpty(action))
					continue;

				// Handle return types 
				if (!function.ReturnType.Name.ToLower().Contains("void"))
				{
					if (function.ReturnType.IsArray)
						searchTree.Push(function.ReturnType.ArrayType);
					else
						searchTree.Push(function.ReturnType);
				}

				// Handle parameter types
				foreach (var parameter in function.Parameters)
				{
					var parameterType = parameter.CodeParameter.Type;
					if (parameterType.TypeKind.ToString() == "vsCMTypeRefCodeType")
						searchTree.Push(parameter.Type);
				}
			}
		}

		// Find nested return types
		while (searchTree.Count != 0) 
		{
			var searchType = searchTree.Pop();

			// Skip already known types
			if (knownTypesString.Contains(searchType.FullName))
				continue;
				
			// Handle base type
			if (searchType.BaseType != null) 
			{
				// If a base type exists, it must be added before the current type since in Javascript a class must be declared after its base class.
				// Therefore we re-add the current type and  add its base class on top of the stack to process it first
				if (!knownTypesString.Contains(searchType.BaseType.FullName))
				{
					searchTree.Push(searchType);
					searchTree.Push(searchType.BaseType);
					continue;
				}
			}

			codeTypes.Add(searchType);
			knownTypesString.Add(searchType.FullName);
	
			// Handle complex members on type
			var members = DteHelper.TryGetMembers(searchType.Type, _project);
			foreach (var member in members)
			{
				// Only do complex classes
				if (member.TypeRef.TypeKind.ToString() != "vsCMTypeRefCodeType")
					continue;

				if (!Helper.IsPrimitiveType(member.Type.FullName) && !knownTypesString.Contains(member.Type.FullName)) 
				{
					if (member.IsArray)
					{
						searchTree.Push(DteHelper.ConvertToScriptCodeType(member.ArrayType.Type, _project));
					}
					else
					{
						searchTree.Push(DteHelper.ConvertToScriptCodeType(member.Type, _project));
					}
				}	
			}
		}
		 
		return codeTypes;
	}

	private string PrintModelTree(List<ScriptCodeType> types)
	{
		var sb = new StringBuilder();

		var groupedNamespace = types
			.GroupBy(t => t.Namespace)
			.Select(grp => new { Namespace = grp.Key, Types = grp.ToList() });

		foreach (var typeGroup in groupedNamespace)
		{
			sb.AppendLine("export namespace " + typeGroup.Namespace + " { ");

			foreach (var type in typeGroup.Types)
			{
				sb.AppendLine("");
				sb.Append(PrintComment(type.Comment, 1, 1));

				var baseClassName = "";
				var className = type.Name;

				// Handle base types 
				// TODO: Handle multiple base type if interface implementation
				if (type.BaseType != null)
				{
					baseClassName = type.BaseType.Name;
					sb.AppendLine("\texport class " + className + " extends " + baseClassName + " { ");
				}
				else 
				{
					sb.AppendLine("\texport class " + className + " { ");
				}

				sb.Append(PrintMembers(type, 2));
				sb.AppendLine("\t}");
			}
			sb.AppendLine("}");
		}

		return sb.ToString();
	}

	private string PrintMembers(ScriptCodeType type, int level)
	{
		var sb = new StringBuilder();
		var members = DteHelper.TryGetMembers(type.Type, _project);

		foreach (var member in members) 
		{
			// Filter everything but public methods
			if (!member.IsPublic)
				continue;

			sb.Append(PrintComment(member.Comment, level));
			sb.Append(new String('\t', level) + Helper.FirstLetterToLowerCase(member.Name) + ": ");	

			if (member.Type.ToString() != "vsCMTypeRefCodeType") 
			{
				if (member.IsArray)
					sb.AppendLine(Helper.ConvertToTypescriptType(member.ArrayType.FullName) + "[];");	
				else	
					sb.AppendLine(Helper.ConvertToTypescriptType(member.Type.FullName) + ";");	
			}

			// TODO: Handle default values
		}

		return sb.ToString();
	}

	private string PrintComment(string comment, int level, int skip = 2)
	{
		var sb = new StringBuilder();

		if (!String.IsNullOrEmpty(comment))
		{
			var comments = comment.Split('\n').Skip(skip);
			var commentArray = comments.Take(comments.Count() - skip).ToArray();
			sb.Append(new String('\t', level ) + "// " + String.Join(new String('\t', level) + "// ", commentArray));
		}

		return sb.ToString();
	}
}

public static class Helper
{

	public static bool IsPrimitiveType(string typeFullName)
	{
		var typescriptShortenedNames = new Dictionary<string, string> 
		{
            { "System.DateTime", "Date" },
            { "System.DateTime?", "Date" },
        };

		if (typescriptShortenedNames.ContainsKey(typeFullName))
		{
			return true;
		}
	
		return false;
	}

	public static string FirstLetterToLowerCase(string text)
	{
		return text.Substring(0,1).ToLower() + text.Substring(1,text.Length - 1);
	}
	
	public static string TryGetActionAttribute(List<ScriptCodeAttribute> attributes)
	{
		foreach (var attribute in attributes)
		{
			if (attribute != null)
			{        
				switch (attribute.Name)
				{
					case "HttpPost":
					case "HttpPostAttribute":
						return "post";
					case "HttpPut":
					case "HttpPutAttribute":
						return "put";
					case "HttpGet":
					case "HttpGetAttribute":
						return "get";
					case "HttpDelete":
					case "HttpDeleteAttribute":
						return "delete";
				
				}
			}
		}
        
		return String.Empty;
	}

	public static string ConvertToTypescriptType(string typeFullName)
    {
		var typescriptShortenedNames = new Dictionary<string, string> 
		{
            { "System.Int16", "short" },
            { "System.Int32", "number" },
            { "System.Int64", "number" },
            { "System.String", "string" },
            { "System.Single", "number" },
            { "System.Double", "numb" },
            { "System.Boolean", "Boolean" },
            { "System.Char", "string" },
            { "System.Object", "any" },
            { "System.Decimal", "number" },
            { "System.DateTime", "Date" },
            { "System.DateTime?", "Date" },
        };

		if (typescriptShortenedNames.ContainsKey(typeFullName))
		{
			return typescriptShortenedNames[typeFullName];
		}
	
		return typeFullName;
	}
}
public static class DteHelper 
{

    public static bool IsPublic(CodeElement codeElement)
    {
        if (codeElement is CodeType)
            return ((CodeType)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeProperty)
            return ((CodeProperty)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeFunction)
            return ((CodeFunction)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeVariable)
            return ((CodeVariable)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeStruct)
            return ((CodeStruct)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeDelegate)
            return ((CodeDelegate)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        return false;
    }


	public static List<ScriptCodeType> TryGetMembers(CodeType type, EnvDTE.Project project) 
	{
		var result = new List<ScriptCodeType>();

		foreach (CodeElement element in type.Members)
		{
			var member = new ScriptCodeType();
			 
			switch (element.Kind)
			{
				case vsCMElement.vsCMElementVariable:
				{
					var codeVariable = (element as CodeVariable);
					member = DteHelper.ConvertToScriptCodeType(codeVariable.Type.CodeType, project);
					member.TypeRef = codeVariable.Type;
					member.IsPublic = IsPublic(element);
					member.Name = element.Name;
					member.Comment = codeVariable.DocComment;
					break;
				}
				case vsCMElement.vsCMElementProperty:
				{ 
					var codeProperty = (element as CodeProperty);
					member = DteHelper.ConvertToScriptCodeType(codeProperty.Type.CodeType, project);
					member.TypeRef = codeProperty.Type;
					member.IsPublic = DteHelper.IsPublic(element);
					member.Name = element.Name;
					member.Comment = codeProperty.DocComment;
					break;
				}
				case vsCMElement.vsCMElementFunction:
				{
					continue;
				}
			}

			if (member.Type == null)
				throw new ArgumentException(String.Format("Cannot get members for type: {0}. Cannot convert CodeElement to Type for member: {1}. Kind: {2}", type.Name, member.Name, element.Kind));

			result.Add(member);
		}

		return result;
	}

	public static string TryGetRouteAttribute(CodeFunction method) 
	{
		foreach(CodeElement attributeElement in method.Attributes)
		{
			CodeAttribute attribute = attributeElement as CodeAttribute;
            
			if(attribute != null)
			{        
				switch (attribute.Name)
				{
					case "Route":
					case "RouteAttribute": 
						return attribute.Value.Replace("\"", "");
				}
			}
		}
        
		return String.Empty; 
	}
	public static string TryGetRouteAttribute(CodeClass method) 
	{
		foreach(CodeElement attributeElement in method.Attributes)
		{
			CodeAttribute attribute = attributeElement as CodeAttribute;
            
			if(attribute != null)
			{        
				switch (attribute.Name)
				{
					case "Route":
					case "RouteAttribute":
						return attribute.Value.Replace("\"", "");
				}
			}
		}
        
		return String.Empty;
	}

	public static List<CodeParameter> FindParameters(CodeFunction method) 
	{
		var result = new List<CodeParameter>();

		foreach(CodeElement element in method.Parameters)
		{
			CodeParameter parameter = element as CodeParameter;

			if (parameter != null)
			{
				result.Add(parameter);
			}
		}

		return result;
	}
	public static List<CodeFunction> FindFunctions(CodeElements elements)
	{
		List<CodeFunction> functions = new List<CodeFunction>();
        
		foreach (CodeElement element in elements)
		{
			CodeFunction function = element as CodeFunction;
        
			if (function != null)
				functions.Add(function);            
		}
    
		return functions;
	}

	public static List<CodeClass> FindClasses(CodeElements elements, string className, string searchNamespace, bool isNamespaceOk) 
	{
		var result = new List<CodeClass>();

		if (elements == null) 
			return result;

		foreach (CodeElement element in elements) {
			if (element is CodeNamespace) {
				CodeNamespace ns = element as CodeNamespace;
				if (ns != null) {
					if (ns.FullName == searchNamespace)
						result.AddRange(FindClasses(ns.Members, className, searchNamespace, true));
					else
						result.AddRange(FindClasses(ns.Members, className, searchNamespace, false));
				}
			} else if (element is CodeClass && isNamespaceOk) {
				CodeClass c = element as CodeClass;
				if (c != null) {
					if (c.FullName.Contains(className) && !c.IsAbstract)
						result.Add(c);

					result.AddRange(FindClasses(c.Members, className, searchNamespace, true));
				}
			}
		}

		return result;
	}
	
	public static List<CodeType> FindBaseTypes(CodeType codeType) 
	{
		var result = new List<CodeType>();

		// Handle inherited types for parameter
		foreach (CodeElement elem in codeType.Bases)
		{
			// TODO: Handle interfaces (CodeClass.ImplementedInterfaces)
			// TODO: Handle generic interfaces http://stackoverflow.com/questions/12662506/how-to-get-the-generic-type-parameters-for-a-envdte-codeinterface
			// TODO: Handle multiple inheritence, by adding the type to the search tree we can handle recursive inheritence
			if (elem is CodeInterface)
			{
			}

			if (elem is CodeClass)
			{
				var baseClass = (elem as CodeClass);

				if (baseClass.IsCodeType) 
				{
					var baseType = (baseClass as CodeType);

					// All classes has base class System.Object, we only want those that has an explicit inherited class
					if (baseType.FullName == "System.Object")
						continue;

					result.Add(baseType);
				}
			}
		}

		return result;
	}

	public static ScriptCodeType ConvertToScriptCodeType(CodeType codeType, EnvDTE.Project project )
	{
		var result = new ScriptCodeType();
		result.Name = codeType.Name;
		result.FullName = codeType.FullName;
		result.Namespace = codeType.Namespace.FullName;
		result.Comment = codeType.DocComment;
		result.Type = codeType;

		// TODO: Add more C# types here which should be treated as an array type in javascript
		if (codeType.Name == "List" || codeType.Name == "Array")
		{
			// HACK: Fetches the generic type from "System.Collections.Generic.List<Namespace.Type>" using string manipulation
			var genericTypeName = codeType.FullName.Split('<', '>')[1]; 
			var genericType = project.CodeModel.CodeTypeFromFullName(genericTypeName);
			result.IsArray = true;
			result.ArrayType = DteHelper.ConvertToScriptCodeType(genericType, project);
		}

		var baseTypes = DteHelper.FindBaseTypes(codeType);

		// Handle inherited types for parameter
		foreach (CodeType baseType in baseTypes)
		{
			result.BaseType = DteHelper.ConvertToScriptCodeType(baseType, project);
		}

		return result;
	}
}
#>